from antlr4 import *
from antlr4.InputStream import InputStream
from antlr4.error.Errors import ParseCancellationException
from antlr4.tree.Tree import TerminalNodeImpl
from pydot import Dot, Edge, Node
from dist.qlangLexer import qlangLexer
from dist.qlangParser import qlangParser
from dist.qlangListener import qlangListener
from dist.qlangVisitor import qlangVisitor


def build_parser(text: str) -> qlangParser:
    """
    Build parser object generated by antlr
    :param text:
    :return:
    """
    data = InputStream(text)
    lexer = qlangLexer(data)
    stream = CommonTokenStream(lexer)
    return qlangParser(stream)


def validate_program(program: str) -> bool:
    """
    Checks whether program is valid
    :param program:
    :return:
    """
    parser = build_parser(program)
    parser.program()
    if parser.getNumberOfSyntaxErrors() == 0:
        return True
    else:
        return False



class SyntaxTreeVisitor(qlangVisitor):
    def __init__(self, text: str):
        parser = build_parser(text)
        self.ast = parser.program()
        if parser.getNumberOfSyntaxErrors() != 0:
            raise ParseCancellationException("Not valid program")

        self.tree = Dot("tree", graph_type="digraph")
        self.number_nodes = 0
        self.nodes = {}
        self.rules = qlangParser.ruleNames
        super(qlangVisitor, self).__init__()

    def save_in_dot(self, path: str):
        ParseTreeWalker().walk(self, self.ast)
        self.tree.write(str(path))

    def enterEveryRule(self, rule: ParserRuleContext):
        if rule not in self.nodes:
            self.number_nodes += 1
            self.nodes[rule] = self.number_nodes
        if rule.parentCtx:
            self.tree.add_edge(Edge(self.nodes[rule.parentCtx], self.nodes[rule]))
        label = self.rules[rule.getRuleIndex()]
        self.tree.add_node(Node(self.nodes[rule], label=label))

    def exitEveryRule(self, rule: ParserRuleContext):
        pass